#ifndef LIBQOTP_H_20231127
#define LIBQOTP_H_20231127

#include <cstdint>

#include <QString>
#include <QDateTime>
#include <QCryptographicHash>

/**
 * @def QOTP_MINIMUM_DIGIT
 *
 * Defines the minimum number of digits for the generated HOTP value.
 *
 * This macro sets the lower limit on the length of the one-time password (OTP) generated by the HOTP algorithm.
 * The RFC 4226 recommends that OTPs should have a minimum length of 6 digits to ensure a reasonable level of security.
 * Users of the library can define this macro to increase the minimum length requirement if desired.
 *
 * The default value is set to 6 if it is not defined prior to including this library.
 *
 * Usage example:
 *     #define QOTP_MINIMUM_DIGIT 6
 *     #include <libqotp/qotp.h>
 */
#ifndef QOTP_MINIMUM_DIGIT
#define QOTP_MINIMUM_DIGIT 6
#endif

/**
 * @def QOTP_MAXIMUM_DIGIT
 *
 * Defines the maximum number of digits for the generated HOTP value.
 *
 * This macro sets the upper limit on the length of the one-time password (OTP) generated by the HOTP algorithm.
 * While the HOTP algorithm can technically generate OTPs of any length, values longer than 8 digits are typically not
 * user-friendly and are often not supported by OTP systems. Users of the library can define this macro to decrease the
 * maximum length requirement if desired, keeping in mind usability considerations.
 *
 * The default value is set to 8 if it is not defined prior to including this library.
 *
 * Usage example:
 *     #define QOTP_MAXIMUM_DIGIT 8
 *     #include <libqotp/qotp.h>
 */
#ifndef QOTP_MAXIMUM_DIGIT
#define QOTP_MAXIMUM_DIGIT 8
#endif

namespace libqotp
{
   /**
    * Generates an HMAC-based One-Time Password (HOTP).
    *
    * This function implements the HOTP algorithm as specified in RFC 4226.
    * It generates a one-time password using a shared secret key and a moving factor (counter).
    *
    * RFC 4226 (https://tools.ietf.org/html/rfc4226) states that the shared secret must be strong,
    * and the counter is a moving factor which ensures a different password is generated each time.
    *
    * @param secret The shared secret key as a QByteArrayView.
    * @param counter The moving factor (counter value) for HOTP generation.
    * @param digits The desired length of the OTP. Defaults to 6 if not specified.
    * @param digitMinimum The minimum number of digits the OTP should have. This value should
    *        not be less than the global QOTP_MINIMUM_DIGIT setting. Defaults to QOTP_MINIMUM_DIGIT.
    * @param digitMaximum The maximum number of digits the OTP should have. This value should
    *        not exceed the global QOTP_MAXIMUM_DIGIT setting. Defaults to QOTP_MAXIMUM_DIGIT.
    * @param algorithm The cryptographic hash algorithm to be used. Defaults to QCryptographicHash::Sha1.
    *        The inclusion of other algorithms is primarily to support TOTP as per RFC 6238 and not intended
    *        for regular HOTP as defined by RFC 4226.
    * @return A QString containing the OTP. Returns an empty string in case of an error.
    *
    * The function ensures that the length of the generated OTP is within the specified
    * minimum and maximum digit limits. If the 'digits' parameter is outside the range
    * defined by 'digitMinimum' and 'digitMaximum', the function returns an empty string.
    */
   QString hotp(
      QByteArrayView secret,
      uint64_t counter,
      unsigned int digits = 6,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1);

   /**
    * Generates a Time-Based One-Time Password (TOTP).
    *
    * This function implements the TOTP algorithm as specified in RFC 6238.
    * It generates a one-time password using a shared secret key and the current time as the moving factor.
    *
    * @param secret The shared secret key as a QByteArrayView.
    * @param currentUnixTime The current Unix epoch timestamp in seconds for the TOTP calculation. Defaults to the current time.
    * @param timeStep The time step in seconds. The RFC recommends 30 seconds.
    * @param epoch The Unix epoch for the TOTP calculation. Usually 0 (Unix epoch).
    * @param digits The desired length of the OTP. Defaults to 6.
    * @param digitMinimum The minimum number of digits the OTP should have. Defaults to QOTP_MINIMUM_DIGIT.
    * @param digitMaximum The maximum number of digits the OTP should have. Defaults to QOTP_MAXIMUM_DIGIT.
    * @return A QString containing the TOTP or an empty string in case of an error.
    */
   QString totp(
      QByteArrayView secret,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1);

   /**
    * Calculates the expiration timestamp (in UTC) for the current TOTP window.
    *
    * @param currentUnixTime The current Unix time in seconds. Defaults to the current time if not specified.
    * @param epoch The Unix epoch for the TOTP calculation. Usually 0 (Unix epoch).
    * @param timeStep The time step in seconds. The RFC recommends 30 seconds.
    * @return A quint64 representing the expiration Unix timestamp of the current TOTP window.
    */
   quint64 totp_expire_time(
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      quint64 epoch = 0,
      unsigned int timeStep = 30);

   // Convenience
   QString totp_sha256(
      QByteArrayView secret,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT);

   // Convenience
   QString totp_sha512(
      QByteArrayView secret,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT);

   // Convenience
   QString hotp_base32(
      const QString& base32,
      uint64_t counter,
      unsigned int digits = 6,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1);

   // Convenience
   QString totp_base32(
      const QString& base32,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1);

   // Convenience
   QString totp_base32_sha256(
      const QString& base32,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT);

   // Convenience
   QString totp_base32_sha512(
      const QString& base32,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT);

   // Convenience
   QString hotp_base64(
      const QByteArray& base64,
      uint64_t counter,
      unsigned int digits = 6,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1,
      QByteArray::Base64Options options = QByteArray::Base64Option::Base64Encoding);

   // Convenience
   QString totp_base64(
      const QByteArray& base64,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QCryptographicHash::Algorithm algorithm = QCryptographicHash::Sha1,
      QByteArray::Base64Options options = QByteArray::Base64Option::Base64Encoding);

   // Convenience
   QString totp_base64_sha256(
      const QByteArray& base64,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QByteArray::Base64Options options = QByteArray::Base64Option::Base64Encoding);

   // Convenience
   QString totp_base64_sha512(
      const QByteArray& base64,
      quint64 currentUnixTime = QDateTime::currentDateTimeUtc().toSecsSinceEpoch(),
      unsigned int timeStep = 30,
      quint64 epoch = 0,
      unsigned int digits = 8,
      unsigned int digitMinimum = QOTP_MINIMUM_DIGIT,
      unsigned int digitMaximum = QOTP_MAXIMUM_DIGIT,
      QByteArray::Base64Options options = QByteArray::Base64Option::Base64Encoding);

   /**
    * Decodes a Base32 encoded string to a QByteArray.
    *
    * This function decodes a string encoded in Base32 according to RFC 4648.
    * It supports the standard Base32 alphabet (A-Z2-7) and is case-insensitive.
    *
    * Error handling:
    * - Ignores non-Base32 characters (based on the standard Base32 alphabet).
    * - Handles padding characters ('=') properly.
    * - Returns an empty QByteArray if there are illegal characters or other inconsistencies.
    *
    * @param base32String The Base32 encoded string to decode.
    * @return A QByteArray containing the decoded data, or an empty QByteArray in case of an error.
    */
   QByteArray base32_decode(const QString &base32String);
}

#endif
